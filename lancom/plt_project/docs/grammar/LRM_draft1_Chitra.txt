1 Lexical Conventions
---------------------

A LANCOM program block consists of a single translation unit stored in files. Each file is written using ASCII character set and must be saved with a <.lancom> extension

1.1 Program Block
-----------------
LANCOM uses the keyword pair 'prog' and 'endprog' to identify a program block. The statements are enclosed within these key words.


1.2 Comments
------------
LANCOM recognizes single line comments. Comments in LANCOM begin with a '#' and terminate with an end of line (EOL) character. Multiline comments can be achieved by prefixing each single line with a '#'
	e.g: 	# This is a comment EOL
		# This is a multiline comment EOL
EOL supports both unix based line feed and dos based carriage return schemes.
All comments are ignored by the LANCOM compiler.

1.3 WhiteSpaces
---------------
LANCOM compiler ignores whitespaces unless they are bounded by the double quote character '"' on either side. Whitespaces include blank character ' ', tabs '\t' and EOL characters '\r' '\n'

1.4 Tokens
----------
Tokens fall into five major categories:
identifier, keywords, constants, operators and delimiters

1.4.1 Identifiers
Identifiers begin with a letter (upper or lower) followed by any sequence of letter or digits and the underscore character. Two lettes are considered equal if their ASCII character codes are equal. Two identifiers are  considered identical if every character in one identifier matches every character in the other.

1.4.2 Keywords
The following words are used as keywords in LANCOM and cannot be used  as anything else unless bounded by quotes:
while if echo TRUE FALSE

1.4.3 Constants
LANCOM uses constants to initialize each of the supported primitive types.
LANCOM supports integer constants, character constants, string constants and boolean constants. String Constants are specified within double quotes '"' on either side of the string literal and character constants are specified within single quotes '''. Boolean constants take the values TRUE and FALSE

1.4.4 Operators
LANCOM supports assignment operators, logical operators, bitwise operators, relational operators, arithmatic operators and unary operators.

Assignment operators include '=' '+=' '-=' '*=' and '/='
Logical operators include '&&' and '||'
Bitwise operators include '|' and '&'
Relational Operators include '==' '!=' '<' '<=' '>' and '>='
Arithmatic operators include '+' '-' '*' and '/'
Unary Operators includes the compliment operator '~'

The precedence of the operators in the increasing order is:
'=' '+=' '-=' '*=' '/=' '||' '&&' '|' '&' '==' '!=' '<' '<=' '>' '>=' '+' '-' '*' '/' '~'

The operators with the same level of precedence are:
'=' '+=' '-=' '*=' '/='
'==' '!='
'<' '<=' '>' '>='
'+' '-'
'*' '/' 

1.4.5 Delimiters
The following charactes are used as separators:
',' - to separate identifiers
';' - to separate statements

1.4.6 Scope
The only scope defined in LANCOM as of now is that of the program block which begins with 'prog' and ends with 'endprog'


2. Control Structures

2.1 Conditional Statements
LANCOM supports a simple 'if-else-endif' statement. 

2.1.1 The 'if' is the keyword used for conditional execution. The statement associated with the if condition are executed once if the condition evaluates to true. 

2.1.2 The 'else' keyword is optional and is used only in conjunction with the if condition. When the condition associated with if evaluates to false, the statements in the else block get executed.

The if block terminates with teh keywork 'endif'

e.g: 	if(expr) 
		statement_1;
	else
		statement_2
	endif 

or 
	if(expr)
		statement_1;
	endif
	

2.2 Iterative Statement
LANCOM supports iteration using the 'while' statement
2.2.1 'while' is a looping construct. The statement block in the while loop is executed as long as the condition specified in the while block evaluates to true. The keyword 'endwhile' identifies the end of the looping block.

e.g:	while(condition)
		statement_1;
		statement_2;
	endwhile

3. Grammar
The LANCOM Grammar is specified below:
> tokens {
> > 	PLUS 	= '+' ;
> > 	MINUS	= '-' ;
> > 	MULT	= '*' ;
> > 	DIV	= '/' ;
> > 	
> > }
> > 
> > @members {
> >     public static void main(String[] args) throws Exception {
> > 
> >         ConditionalLexer lex = new ConditionalLexer(new ANTLRFileStream(args[0]));
> >        	CommonTokenStream tokens = new CommonTokenStream(lex);
> > 
> > 
> >        ConditionalParser parser = new ConditionalParser(tokens);
> > 
> >         try {
> >             parser.expr();
> >         } catch (RecognitionException e)  {
> > 
> >             e.printStackTrace();
> >         }
> >     }
> > }
> > 
> > /*------------------------------------------------------------------
> >  * PARSER RULES
> >  *------------------------------------------------------------------*/
> > prog	
> >	:	'prog' statement_list 'endprog'
> > 	;
> > 	
> > statement_list
> > 	:	statement+
> > 	;
> > 
> > statement
> > 	:	condition_statement
> > 	|	iteration_statement
> > 	|	statement_expr
> > 	|	print_statement
> > 	;
> > 	
> > statement_expr
> > 	:	';'
> > 	|	expression ';'
> > 	;
> > 	
> > condition_statement
> > 	:	'if' '(' expression ')' statement_list ('else' statement_list)? 'endif'
> > 	;
> > 	
> > iteration_statement
> > 	:	'while' '(' expression ')' statement_list 'endwhile'
> > 	;
> > 	
> > print_statement
> > 	:	'echo' STRING ';'
> > 	;
> > 	
> > expression
> > 	:	assignment_expr (',' assignment_expr)*
> > 	;
> > 	
> > assignment_expr
> > 	:	lvalue assignment_operator assignment_expr
> > 	| 	conditional_expr
> > 	;
> > 
> > lvalue	
> >	:	factor
> >	;
> > 		
> > conditional_expr
> > 	:	logicalOR_expr( '?' expression ':' conditional_expr)?
> > 	;
> > 	
> > logicalOR_expr
> > 	:	logicalAND_expr ('||' logicalAND_expr)*
> > 	;
> > 
> > logicalAND_expr
> > 	:	bitwiseOR_expr ('&&' bitwiseOR_expr)*
> > 	;
> > 	
> > bitwiseOR_expr
> > 	:	bitwiseAND_expr ('|' bitwiseAND_expr)*
> > 	;
> > 
> > bitwiseAND_expr
> > 	:	equality_expr ('&' equality_expr)*
> > 	;
> > 	
> > equality_expr
> > 	:	relational_expr ( ('==' | '!=') relational_expr)*
> > 	;
> > 	
> > relational_expr 
> > 	:	expr ( ('<'|'>'|'<='|'>=') expr)*
> > 	;
> > 	
> > 
> > expr	: term ( ( PLUS | MINUS )  term )* ;
> > 
> > term	: unary_expr ( ( MULT | DIV ) unary_expr )* ;
> > 
> > unary_expr
> > 	:	postfix_expression
> > 	|	'~' unary_expr
> > 	//|	'-' unary_expr 
> > 	//|	'!' unary_expr
> > 	;
> > 
> > postfix_expression
> > 	:	factor ('.'ID)*
> > 	;
> > 
> > assignment_operator
> > 	:	'='
> > 	|	'*='
> > 	|	'/='
> > 	|	'+='
> > 	|	'-='
> > 	;
> > 
> > factor	: ID 
> > 	| constant	
> > 	//| '(' expression ')' 
> > 	;
> > 
> > constant:	NUMBER
> > 	|	STRING
> > 	|	CHAR
> > 	|	'TRUE'
> > 	|	'FALSE'
> > 	;
> > 
> > /*------------------------------------------------------------------
> >  * LEXER RULES
> > 
> >  *------------------------------------------------------------------*/
> > 
> > NUMBER	: (DIGIT)+ ;
> > 
> > ID	:	LETTER (LETTER|DIGIT)*;
> > 
> > CHAR	:	'\'' ( EscapeSequence | ~('\''|'\\') ) '\'';
> > 
> > STRING	:	'"' ( EscapeSequence | ~('\\'|'"') )* '"';
> > 
> > fragment DIGIT	: '0'..'9' ;
> > 
> > fragment LETTER	:	'A'..'Z'
> > 	|	'a'..'z'
> > 	|	'_'
> > 	;
> > 	
> > fragment
> > EscapeSequence
> > 	:   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
> > 	;
> > 	
> > WHITESPACE : ( '\t' | ' ' | '\r' | '\n'| '\u000C' )+ 	{ $channel = HIDDEN; } ;
> > 
> > LINE_COMMENT :	'#' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;};

